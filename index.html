<!DOCTYPE html>
<html>
    <head>
            <!-- <span> inline container to group elements for styling purposes-->
                <!--It’s best to use a <span> element when you want to target a specific piece of content that is inline, or on the same line as other text-->
                <!--<div> block container to group elements for styling purposes-->
                    <!--<div>s allow us to group HTML elements to apply the same styles for all HTML elements inside. We can also style the <div> element as a whole-->
                    <!--The fieldset element is used to group related inputs and labels together in a web form. fieldset elements are block-level elements, meaning that they appear on a new line.-->
                    <!--The legend element acts as a caption for the content in the fieldset element. It gives users context about what they should enter into that part of the form.-->
                    <!--You can use the id selector to target a specific element with an id attribute. An id selector is defined by placing the hash symbol # directly in front of the element's id value.-->
                    <!--/* comment here */ comments in css looks like this-->
                    <!--article elements commonly contain multiple elements that have related information. -->
                    <!-- p elements are block-level elements, so they take up the entire width of their parent element.To get them on the same line, you need to apply some styling to the p elements so they behave more like inline elements -->
                     <!--You can give your menu some space between the content and the sides with various padding properties.-->
                      <!-- margin-top and margin-bottom refers to the invisible space outside elements. its default value is about 10px; -->
                       <!-- This is due to the browser having some default top margin for the h1 element.Change the top margin of the h1 element to 0 to remove all the top margin.-->
                      <!--To make the footer links the same color regardless if a link has been visited, use a type selector for the anchor element (a) and use the value black for the color property.-->
                      <!--You change properties of a link when the link has actually been visited by using a pseudo-selector that looks like a:visited { propertyName: propertyValue; }.-->
                      <!--You change properties of a link when the mouse hovers over them by using a pseudo-selector that looks like a:hover { propertyName: propertyValue; -->
                      <!--You change properties of a link when the link is actually being clicked by using a pseudo-selector that looks like a:active { propertyName: propertyValue; }-->
                      <!-- img elements are "like" inline elements.To make the image behave like heading elements (which are block-level), create an img type selector and use the value block for the display property and use the applicable margin-left and margin-right values to center it horizontally.-->
                       <!-- After changing img which behave like inline elements into block elements, you can use the margin-left and margin-right properties to center the image horizontally.-->
                        <!--A relative path is a filename that shows the path to a local file (a file on the same website, such as ./index.html) versus an absolute path (a full URL, like https://www.codecademy.com/learn/learn-html which is stored in a different folder). The ./ in ./index.html tells the browser to look for the file in the current folder.-->
                        <!--When users visit our site, we want them to be able to click a link and have the page automatically scroll to a specific section.In order to link to a target on the same page, we must give the target an id attribute and a unique value.eg. <a href="#top">Click here to go to the top</a>-->
                        <!--Just like table data, a table heading must be placed within a table row.-->
                        <!--the use of the scope attribute, which can take one of two values:
                         row - this value makes it clear that the heading is for a row.
                        col - this value makes it clear that the heading is for a column.-->
                        <!--Data can span columns using colspan attribute. The attribute accepts an integer (greater than or equal to 1) to denote the number of columns it spans across.-->
                        <!--After users type into the <input> element, the value of the value attribute becomes what is typed into the text field. The value of the value attribute is paired with the value of the name attribute and sent as text when the form is submitted.-->
                        <!-- if we wanted to limit what numbers our users could type we might consider using a different type value. Another option we could use is setting type to "range" which creates a slider.-->
                         <!-- The <input> is associated to the <datalist> via the <input>‘s list attribute and the id of the <datalist>ie.they are the same-->
                            <!--The <form>‘s method attribute determines how the information is sent and processed.-->
                                <!--<header>is a container usually for either navigational links or introductory content containing <h1> to <h6> headings.-->
                                    <!--The <article>element holds content that makes sense on its own.-->
                        <!--<aside> element is used to mark additional information that can enhance another element but isn’t required in order to understand the main content.-->    
                            <!--audio appears like this eg.<audio controls><source src=""></audio>-->     
                            <!--videos appear like this eg.<video src="" controls>Video not supported</video>--> 
                            <!--<embed> tag  can be used to add local files as well as media content straight from some other websites.It is a self closing tag-->     
                                <!--internal css is always written in the head tag.Don't forget the type="text/css"--> 
                                <!-- Multiple classes can be added to an element by listing them in the class attribute and separating them with a space-->
                                 <!-- block elements forces new lines and accept margin and paddings which affects their layouts eg.<div>, {<h1>-<h6>}, <p>,<footer>,<article> and <section> -->
                                  <!-- inline elements flows in line and doesn't break new lines. its not affected by margin. However, padding applies to it but it doesn't affect its size because you cant give inline elements height. it doesn't affect the size of the content inside it.its just messing with space between the content and the border eg. links,buttons,labels.<em>,<strong>-->
                                   <!-- with inline-block, you have the ability to set margin,height and padding like a block element if need be but still have the ability to have them on the same line eg. images -->
                                    <!-- You can select the last element of a specific type using the last-of-type CSS pseudo-class, like this: .class:last-of-type { property: value; }  this targets the last element of the class.-->
                                     <!-- you can also select an input with a peculiar type like this : input[type="email"] { property: value; } -->
                                     <!-- a property of width and a value of unset means that the width will be set to the default value of the element.-->
                                      <!--IDs override the styles of type and classes, they should be used sparingly and only on elements that need to always appear the same.  -->
                                      <!-- id overrides class as class is more general than id. Class overrides type as type is more general than class.-->
                                       <!-- To make styles easy to edit, it’s best to style with a type selector, if possible. If not, add a class selector. If that is not specific enough, then consider using an ID selector. -->
                                        <!-- In order to center an element, a width must be set for that element. Otherwise, the width of the div will be automatically set to the full width of its containing element, like the <body> -->
                                            <!-- Overflow property sets the behavior when content does not fit in its parent element. It can be set to visible, hidden, scroll, or auto.-->
                                             <!--*{margin:0; padding:0} resets the default margin and padding of all elements in a web browser and gives the chance for developers to work with a clean slate .-->
                                             <!-- box-sizing property controls the type of box model the browser should use when interpreting a web page.The default value of this property is content-box. content-box means that padding and border properties set for an element affects its overall width and height.-->
                                              <!-- *{ box-sizing:border-box} targets all elements on the web page and sets their box model to the border-box model -->
                                               <!-- The border-box model clears all the default paddings and margin in a browser.in cases where padding and border properties are applied, the content of the element will shrink to make room for the padding and border. -->
                                                <!-- The values the position property can take are static, relative, absolute, fixed, and sticky. static is the default value.-->
                                                 <!-- position:relative; This value allows you to position an element relative to its default static position on the web page -->
                                                  <!-- When an element’s position is set to absolute, all other elements on the page will ignore the element and act like it is not present on the page. -->
                                                   <!-- The sticky value is another position value that keeps an element in the document flow as the user scrolls, but sticks to a specified position as the page is scrolled further -->
                                                    <!-- The z-index property controls how far back or how far forward an element should appear on the web page when elements overlap.it only accepts integer values. the default value is 0.-->
                                                     <!-- One way to center an element vertically and horizontally in Css is to set their position to absolute, top,bottom,left and right to zero, and margin to auto -->
                                                     <!--Float usually works for static and relative positioned elements.Floated elements must have a width specified, otherwise,their element will assume the full width of its parent element.
                                                     and changing the float value will not yield any visible results-->
                    <!--The clear property specifies how elements should behave when they bump into each other on the page. they accept values of left -->
                    <!-- With respect to line-height,the unitless value is preferred since it is responsive based on the current font size. -->
                     <!-- text-align:justify;  spaces out text in order to align with the right and left side of the parent element. -->
                      <!-- filter:blur(3px) adds a blur effect to an image -->
                       <!-- The border-radius property accepts up to four values to round the top-left, top-right, bottom-right, and bottom-left corners. -->
                        <!-- transform:rotate(-45deg); rotates an element by 45 degrees anticlockwise -->
                         <!-- The flex-wrap property determines how your flex items behave when the flex container is too small. Setting it to wrap will allow the items to wrap to the next row or column. nowrap (default) will prevent your items from wrapping and shrink them if needed. -->
                          <!-- The justify-content property determines how the items inside a flex container are positioned along the main axis, affecting their position and the space around them. -->
                           <!-- The align-items property positions the flex content along the cross axis. In this case, with your flex-direction set to row, your cross axis would be vertical. -->
                            <!-- object-fit:cover; ensures that the image is scaled to cover the entire area of the element it is contained in.ie.This will tell the image to fill the img container while maintaining aspect ratio -->
                             <!-- The ::after pseudo-element creates an element that is the last child of the selected element.If you give it the same width as the images it will push the last image to the left when the gallery is in a two-column layout -->
                              <!-- justify content :space-between; will add equal space between the items and the edges of the container -->
                               <!-- align content :center; will center the items vertically -->
                                <!-- <p>texts <span> about flex</span></p>,since they're on the same line,applying flex to the <p> will apply it to the <span> as well,with both behaving like flex items -->
                                    <!-- <p>texts</p> <span>about flex</span>, since these two are on different lines, you'd have to wrap them in a container and apply flex to the container -->
                                     <!-- the div:not(.example){ color:red;} selects all div's that do not have the class example and sets their color to red -->
                                      <!-- when a <p> is displayed as a flex, justify content can be used to center the text horizontally or be shifted to its far right as <p> takes up its entire width -->
                                        <!-- rem,em are all units relative to the size of the html -->
                                         <!-- img {width: max(250px, 25vw); In the above example, the width of the image will be 250px if the viewport width is less than 1000 pixels(eg.smart phone or yam ). If the viewport width is greater than 1000 pixels(eg.laptop,tv), the width of the image will be 25vw. This is because 25vw is equal to 25% of the viewport width. -->
                                          <!--  the logo should retain an aspect ratio of 35 / 4, and have padding around the text. -->
                                            <!-- the role attribute can be used to indicate the purpose behind an element on the page to assistive technologies. eg. <section role="region"></section> -->
                                             <!-- Every region role requires a label, which helps screen reader users understand the purpose of the region. One method for adding a label is to add a heading element inside the region and then reference it with the aria-labelledby attribute.eg.
                                              <section role="region" aria-labelledby="region-label"><h2> Region Label</h2></section> -->
                                              <!-- to be able to link a section on a page to a nav, the href of the link must equate the id of the page -->
                                               <!-- The ::before pseudo-element in CSS is used to insert content before the content of an element. It is often used to add decorative or functional content without modifying the HTML structure.Without its content property,it'll be rendered inaccessible.Some common uses eg.Adding icons or symbols before text,Creating decorative shapes or lines,Inserting dynamic content using the attr() function,Enhancing design elements without altering the HTML. -->
                                                <!-- The :first-of-type pseudo-selector is used to target the first element that matches the selector. eg. h1 .flex span:first-of-type{}, this targets the first span element in the element with a class of flex in the h1 element -->
                                                 <!-- The :last-of-type pseudo-selector does the exact opposite - it targets the last element that matches the selector -->
                                                <!-- On the topic of visual accessibility, contrast between elements is a key factor. For example, the contrast between the text and the background of a heading should be at least 4.5:1. -->
                                                 <!-- sr-only
                                                position: absolute;
                                                width: 1px;
                                                height: 1px;
                                                padding: 0;
                                                margin: -1px;
                                                overflow: hidden;
                                                clip: rect(0, 0, 0, 0);
                                                white-space: nowrap;
                                                border: 0;} -->
                                                <!-- span[class="sr-only"] selector will select any span element whose class includes sr-only -->
                                                 <!-- The CSS clip property is used to define the visible portions of an element.Set the span[class~="sr-only"] selector to have a clip property of rect(1px, 1px, 1px, 1px) -->
                                                  <!-- The clip-path property determines the shape the clip property should take. Set the clip-path property to the value of inset(50%), forming the clip-path into a rectangle within the element. -->
                                                   <!-- The calc() function is a CSS function that allows you to calculate a value based on other values. eg. .example{ margin:10px width:Calc(10px + 20px); } -->
                                                    <!-- p[class]{} selects all paragraph elements that have a class attribute regardless of the class value -->
                                                     <!-- span:not[class="sr-only"] will target all span elements that do not have the class sr-only -->
                                                      <!-- Rather than having to constantly double-check you are not overwriting your earlier properties, you can use the !important keyword to ensure these properties are always applied, regardless of order or specificity.eg. p{color: blue !important ;} will not be overridden by p{ color:green } even if it comes later in the document -->
                                                       <!-- border-collapse:collapse ; means they allow cell borders to collapse into a single border, instead of a border around each cell i.e is used to collapse the borders of a table so that they do not overlap -->
                                                        <!-- in relation to table data(td), always set their width to 100vw to ensure they take up the full view width of the table.always remember the min-width and the max-width -->
                                                         <!-- tables uses <caption></caption> to inform what the table is about -->
                                                         <!-- [attribute="value"] targets elements that have the specified attribute with the specified value.eg. p[class="total"] targets all paragraph elements that only have a class attribute with the value total -->
                                                          <!-- The direct child selector (>) only applies to the immediate children of the parent element, but it doesn't prevent you from overriding the styles of individual children. -->
                                                           <!-- the ::before selector creates a pseudo-element which is the first child of the selected element.eg. p::before{content:"Hello"} -->
                                                            <!-- the ::after selector creates a pseudo-element which is the last child of the selected element.eg. p::after{content:"World"} -->
                                                             <!-- The content property is used to set or override the content of the element. By default, the pseudo-elements created by the ::before and ::after pseudo-selectors are empty, and the elements will not be rendered to the page. Setting the content property to an empty string "" will ensure the element is rendered to the page while still being empty. -->
                                                              <!-- *,*::before,*::after{ box-sizing:border-box} is useful because Pseudo-elements like ::before and ::after are treated as separate elements within their parent element.By default, they inherit the box-sizing property from their parent element. However, explicitly setting box-sizing: border-box for them ensures consistency, even if the parent element’s box-sizing is overridden.-->
                                                               <!-- Using the ::before and ::after pseudo elements, its width and height alongside the background-color weren't visible until the absolute position was applied. this is an essential note to acknowledge in using pseudo elements  -->
                                                                <!--  Variable declarations begin with two dashes (-) and are given a name and a value like this: --variable-name: value; -->
                                                                  <!-- the main advantage of using variables is being able to quickly change many values in your stylesheet by just changing the value of a variable. -->
                                                                   <!-- You should add a fallback value to a variable by putting it as the second value of where you use the variable like this: var(--variable-name, fallback-value). The property will use the fallback value when there's a problem with the variable. -->
                                                                  <!-- :root is a way to target the root element of a document, which is the topmost element in the document tree. It's a shorthand way to select the <html> element without having to use the html selector. -->
                                                                    <!-- :root is commonly used to define global variables, also known as custom properties, that can be used throughout the stylesheet. By defining variables at the :root level, you can make them available to all elements in the document. -->
                                                                     <!-- viewport sizes
                                                                      -desktop & laptop-1200px and above. Large(standard-1200)
                                                                      -tablets and small laptops-768px to 1024px.Medium(standard-992px)
                                                                      -smartphones-320px-6640px.small(768)
                                                                      -Extra small(480)  -->
                                                                      <!-- an element can have two linear gradients. it just has to be separated by a comma  -->
                                                                       <!-- Using linear gradient, you can transition from any color to transparent -->
                                                                        <!-- The "loading" attribute on an img element can be set to lazy to tell the browser not to fetch the image resource until it is needed 
                                                                         (as in, when the user scrolls the image into view). As an additional benefit, lazy loaded elements will not load until the non-lazy elements
                                                                          are loaded - this means users with slow internet connections can view the content of your page without having to wait for the images to load. -->
                                                                          <!-- rel="noreferrer" is an attribute used in HTML links (<a> tags). -->
                                                                            <!--The "Referer" header is a piece of information that the browser sends to
                                                                             the server of the linked page, indicating the URL of the page that the user
                                                                              came from. This can be useful for tracking where users are coming from, but
                                                                               it can also be a security concern, as it can potentially leak sensitive information.
                                                                               By setting rel="noreferrer", you're telling the browser not to send this information, 
                                                                               which can help protect user privacy.  -->
                                                                               <!-- <blockquote cite="https://www.example.com/source">
                                                                                   <p>This is a quotation from another source.</p>
                                                                                                                    </blockquote> 
                                                                               in this eg. the blockquote element contains a text that is 
                                                                               being quoted from another source. the cite attribute provides
                                                                               a reference to the source of the quotation. -->
                                                                               <!-- grid-auto-flow: This property specifies the direction in which the
                                                                                 grid items will be placed.If you wanted to add more elements, but keep them on the same row,
                                                                                  you would need to update grid-template-columns to create additional columns.
                                                                                   As an alternative, you can use the grid-auto-flow property. 
                                                                                   The possible values are: row, column , row dense, column dense.
                                                                                   Setting it to column will tell the algorithm to create new columns
                                                                                    for content as needed. -->
                                                                                    <!-- When you use grid-auto-columns, you can specify the size of the grid columns
                                                                                      that will be created automatically. The property can take a variety of values, 
                                                                                      including: auto,min-content,max-content,length,percentage,fr's -->
                                                                                      <!-- in grid,just as in flexbox,
                                                                                       justify-items is used to align grid items along the main axis of the grid.
                                                                                      align-items is used to align grid items along the cross axis of the grid. -->
                                                                                      <!-- you can use the column-width property to split the text into multiple columns within a container.
                                                                                        The column-width property specifies the minimum width of each column eg.
                                                                                        <div class="container">
                                                                                            <p>Lorem ipsum dolor sit amet, .</p>
                                                                                            <p>Ut enim ad minim veniam, q.</p>
                                                                                            <p>Duis aute irure dolor in.</p>
                                                                                            </div>
                                                                                            CSS .container {
                                                                                                column-width: 200px;
                                                                                                column-gap: 20px;
                                                                                                }
                                                                                               This will split the text into two columns,
                                                                                                with a minimum width of 200px each, and a gap of
                                                                                                 20px between them. -->
                                                                                                 <!-- When you float a text, it will be removed from the normal document flow and will
                                                                                                   be placed to the left or right of its parent container, depending on the value of 
                                                                                                   the float property. -->
                                                                                                   <!-- To clear floats, you can use the clear property, which can be set to left,
                                                                                                     right, or both. This will remove the float from the element and
                                                                                                      restore it to the normal document flow.
                                                                                                      <div style="width: 500px; border: 1px solid black;">
                                                                                                        <p style="float: left; width: 200px; background-color: yellow;">This is a floated text.</p>
                                                                                                        <p style="clear: both;">This is a normal text.</p>
                                                                                                        </div> In this example, the second paragraph will be cleared of the float, which means it will
                                                                                                         be placed below the floated text. -->
                                                                                                                            
         <!--The place-items property can be used to set the align-items
          and justify-items values at the same time. The place-items
           property takes one or two values. If one value is provided,
            it is used for both the align-items and justify-items properties.
             If two values are provided, the first value is used for the 
             align-items property and the second value is used for the justify-items property.  -->
             <!-- By using 1 / -1, the grid item will span from the first column to the last column, 
              effectively covering the entire width of the grid. eg..parent {
                                                                            display: grid;
                                                                             grid-template-columns: repeat(12, 1fr);
                                                                                                                    }

                                                                            .child {
                                                                            grid-column: 1 / -1; /* This child will span all 12 columns */
                                                                            }-->
                                                                            <!-- Tracking-wider is used for letter spacing in tailwind -->
                                                                             <!-- in tailwind,group-hover allows elements to be shown on hover -->
<!-- in tailwind,transform hover:scale-110 duration-150-for transforming how an eg. button appears when hovered over
  transition ease-out duration-500-for transitioning the hovering state smoothly -->
  <!-- The transform-origin property in CSS determines the point around which
    a transformation (such as rotation, scaling, or skewing) is applied to
     an element. It defines the origin point for the transformation in terms
      of the element's coordinate system. -->
      <!--  by default, an element rotates around its center ie. "transform origin:50% 50%" -->
        <!-- "transform-origin:0% 0%"-rotates an element around its top-left corner -->
         <!-- ""transform-origin:100% 100%"-rotates an element around its bottom-right corner" -->
          <!-- "transform-origin is used in conjunction with the transform property such as rotation,scaling,skewing" -->


                                                                                                    <!--Git-->
                                                                                                    <!-- Git is a version control system that helps you track changes in your code.-->
 <!-- in gitbash you'd have to specify with your name and email so as to confirm who made changes and when ie. $ git config --global user.name "your name"  & $ git config --global user.email "email" -->         
  <!--In using git to track files, you must change the directory of the powershell to that of the said file ie. $ cd ~/Desktop/git-practice -->   
  <!--$ls used to list the files in the current folder-->                               
  <!--To turn it into a git repository, you simply use $ git init where init= initialization-->      
  <!--when you later check within your file explorer, you can see the git.folder wit all the repository files-->                 
  <!--$ git status tells us the status of our repository i.e it tells us what changes has been made since our previous version/commit-->   
  <!-- untracked files means any changes made within those will not be recorded by git-->
  <!-- the git has three main states ie. modified/working file, staged and committed-->
      <!--$ git add . adds all files/changes in the current directory to the staging area-->
      <!--$ git reset <file> takes a file/changes out of the staging area-->
        <!--to undo all the changes within the working area, you can use $ git checkout -- "file"-->
      <!-- $ git commit takes a snapshot of all your repository at the moment in time-->
       <!--you can interchange commit for version just for study purposes-->
       <!--$ commit -m "message" allows you to add a message to the commit-->
       <!-- after committing our repository, and we later recognize a spelling mistake with the commit message or an Emittance of a file, we can use $ git commit --amend to correct it or for the latter, $ git add <file> & $ git commit --amend-->
        <!-- git reset --hard HEAD~1 is used to undo the last commit-->
       <!-- after modifying your repository, $ git diff shows the differences between the original file and the modified file-->
        <!--git mv is used to move or rename a file-->
        <!--$ git log shows the commit history-->
        <!--Note : git fundamentally tracks changes in files, not the files themselves-->
        <!-- using $ git checkout (code number), brings you back to that version of your repository-->
         <!--$ git log --all --graph shows you the branching effect in your commit history-->
         <!--the branch name be it "main" or "master" points to the latest commit in the branch-->
         <!-- HEAD in git, tells you the version you are currently operating on  -->
         <!--if you don't want the updated version of a previous file to branch out but to follow the sole branch even though its at the bottom like google docs then the first thing is to make sure the HEAD is at the latest commit on the master branch ie git checkout master ,followed by 2 rules where the checkout needs not only the (code number) but the file name as well ie. $ git checkout (code number) <file name>/ .-->
          <!--a .gitignore file can be used to ignore certain files in your repository. all it needs is for the files to be listed in the .gitignore file-->
          <!-- rm-rf.git is used to remove git from a project-->



          <!--GITHUB-->
          <!-- Github provides us with an online backup to our local repositories and it also possesses 2 way sync i.e any update on our computer gets updated in the online repository and vice versa-->
          <!-- Unlike google drive , github is designed specifically for git repositories -->
           <!-- you need to link your github account to your local repository in order to transfer your local repositories to your remote repositories and that can be done using $ git remote add origin <github repository link>-->
            <!-- $ git remote -v shows the remote repository link-->
            <!-- to remove a link from a remote repository, you can use $ git remote remove <repository name> where <repository name> is likely to be "origin"-->
              <!-- before we get to push files into our github, we need to configure git with our github username i.e git config --global credential.username "TARIQQ-coder" -->
               <!-- to push our local repositories to our remote repositories, we use $ git push origin <branch name however, it should be that of which we want to push from the repository>-->
                  <!-- after pushing your local repository, your remote tracking branch (origin/master) should be of the same version as your local branch (master) when $ git log --all --graph is used-->
                   <!-- the remote branch (origin/master) tells us what the master branch looks like on the remote repository ie on github-->
                    <!-- git push only pushes commits to the remote repository, it does not push untracked files-->
                     <!-- git push origin master -f forces the push of the local branch to the remote repository. it is not an advised practice-->
                      <!-- to clone a remote repository to your computer, you can use $ git clone <github repository link> ie. the https:-->
                        <!-- remote tracking branches don't update automatically.it just reflects the stage it was the last time "YOU" updated it. You'd have to use $ git fetch. This updates all remote tracking branches to its current repository. Maybe a co-worker has added new commits to it -->
                         <!-- To pull a remote repository from github to a local repository,you use $ git pull origin <branch name> -->

               


          <!-- Javascript -->
                                                                                                                <!-- Variables,They act as containers for data that can be referenced and manipulated throughout your code. Variables can hold different types of data, including numbers, strings, objects, arrays, and more. -->
                                                                                                                 <!-- In JavaScript, when you reassign a variable, the previous value that the variable held is not explicitly deleted; rather, the variable simply points to a new value. The old value may still exist in memory if there are other references to it, but the variable itself no longer holds that value. -->
                                                                                                                  <!--if say we create a variable eg let result = 0; and we reassign it in a button say result = result+1; know that after every click , the value of reassigned (variable) i.e result will increase by 1 but if we didn't reassign it in the first place, it will remain the same-->

                                                                                                              <!-- a boolean value accesses whether a value is true or false -->
         <!-- you use a boolean value, you either type true or false -->
          <!-- in the order of operators, bodmas, comparison operators(ie. <,>,===,!==),logical operators (ie.&&,||,!(not)) -->
           <!-- "if statements" lets us write multiple group of codes and decide which code to run based on the condition/boolean value  -->
            <!-- syntax for "if statements".ie. if(boolean /condition){
             code run if condition is true or otherwise run the if statement}else{} -->
             <!-- the AND(&&) operator checks if both booleans values are true before running the code -->
              <!-- the OR(||) operator checks if either of the boolean values is true before running the code -->
               <!-- if creates a scope and limits where variables are accessible -->
                <!-- if statements don't work with only boolean values ,they also work with truthy and falsy values. truthy values encapsulates all values except (0,undefined,NaN,null,false,"") -->
                 <!-- ternary are shortcut for if/else statements -->
                 <!-- the advantage of ternary operator over if statement is that you can save its result as a variable.ie. if its true, the result after the question mark can be saved as a variable. if not the other, will can be saved as a variable -->


                 <!-- MAJOR DISCOVERY -->

                 <!-- Local Variables Reset:
When you define a variable inside a function (a local variable), that variable is created anew each time the function is called. This means that its value is reset to its initial state every time the function runs. -->

<!-- Global Variables Persist:
In contrast, when you define a variable outside of any function (a global variable), it retains its value across multiple function calls. This allows you to avoid resetting the variable each time the function is executed. -->

<!-- In many scenarios, you want to accumulate values rather than reset them. For example, in a scoring system for a game, you want to keep adding points to the player's score rather than starting from zero each time a function is called. -->


                                                                                                    

          <!-- Function is used to reuse codes or multiple codes -->
           <!-- syntax for function is function name(parameters){code to be run} -->
            <!-- Functions allow you to write a piece of code once and reuse it multiple times throughout your project. If you need to make changes to a specific piece of logic, you only have to update it in one place (the function definition) rather than in every instance where the code is repeated. This makes your code easier to maintain.Functions can improve the readability of your code. By giving functions descriptive names, you can make your code self-documenting, which helps other developers (or your future self) understand what the code is doing. -->
             <!-- One recommendation for picking function names is to use a verb . This makes it clear that the function is performing an action. -->
           <!-- if we already have a code and we want to run it again, give it a function and call it -->
           <!-- the only way to get the code in a function to run is to call it -->
            <!-- we call a function by the function name followed by the parameters in the brackets -->
            <!-- when the return statement has a value, calling the function will result in the return value -->
             <!-- the syntax for a return statement is "return value;" -->
             <!-- if a function doesn't have a return statement or a return value, calling it will render it undefined when console.log is used for display -->
               <!-- a return statement helps us get a value out of the function ie. whatever the return value is, it will be equal to the name of the function when called. Since its just a value, console.log() displays the return value in a console and it can be saved as a variable -->
                <!-- the return statement ends the function immediately -->
                <!-- when we return, the code returns back to the point where the function was called -->
                <!-- put the code you want to run in the function body -->

               <!-- the syntax for functions -->
                <!-- no special names like function -->
                 <!-- no numbers to begin the name -->
                  <!-- can't use special characters except:$ and _ -->
                   <!-- use camelCase when naming functions -->

                   <!--functions create a scope and limits and any variable in its curly brackets is only accessible within the curly brackets of the function-->
                    <!-- variables created in the curly brackets only exist in the curly brackets eg. if , functions create a scope -->
                     <!-- variables that can be assessed anywhere in the code are called global variables -->
                      <!-- Functions in javascript can be modified to circumstances where it can work with different variables. In situations as such, the function is called a function with parameters -->
                     <!-- to reuse codes that have small differences, parameters are useful -->
                      <!-- a parameter puts a value into a function -->
                       <!-- a parameter works the same way as a variable. you can save a value inside and use it as a variable ie. you can save in it a boolean , number, string etc -->
                        <!-- using parameter works when you have a value that you want to use in a function so you save it in a parameter , use the parameter to modify the function so when you call the function, the value is used -->
                        <!-- a parameter only exits in the curly brackets of the function -->
                        <!--anytime the function is called, another value can be saved into the parameter. Any value saved inside can be used as a variable -->
                        <!-- a function can have more than one parameter -->
                        <!-- a parameter can be a number ie function name(number){code to be run} -->
                        <!-- to set a default value for a parameter, you can use the assignment operator eg. function name(number = 5){code to be run} -->



                        <!-- OBJECTS-->
                          <!-- objects are used to store multiple values in a single variable -->
                           <!-- the syntax for objects is const name = {key1:value1,key2:value2} -->
                            <!-- say we have an object saved within a variable, we can access the properties of the object using the dot notation ie. variable.property -->
                           <!-- We can correct an existing value of a property using the assignment operator ie. variable.property = new value --> 
                            <!-- Using the dot notation, we can add a new property to an object ie. variable.new property = new value -->
                             <!-- To delete the property of an object, we use the delete keyword ie. delete variable.property -->
                              <!-- objects are also another type of values and as such they can be saved in a variable or console.log()  -->
                               <!-- Instead of having several variables with related data, we can store the related data into one object -->
                                <!-- objects lets us use multiple values together. Unlike having to console.log and use several single variables, we can put them together in an object and use them together using the variable the object is saved in -->
                                 <!-- the syntax for the bracket notation is variable['key'] and it is another way to access the values of an object. note: key is the name of the property -->
                                  <!-- using bracket notation, we can add values to the object ie. variable{['new-key1'] = new value, ['new-key2'] = new value} -->
                                   <!-- another feature of bracket notation is within the bracket, we don't have to necessarily use a string, it can use a variable, some calculations etc  -->
                                    <!-- Inside an object, we can save any type of value. be it strings,numbers,booleans, functions,other objects etc because objects themselves are a type of value -->
                                     <!-- if we save a function inside an object its like a function with parameters.To confirm, console.log(typeof console.log) . it shows function. Meaning "console" is an object with "log" a function, saved inside it-->
                                      <!-- methods are functions that are saved inside an object.NB: they are the functions saved in the objects -->
                                       <!-- Built in objects are built into the language eg. console.log (), math.random(), JSON, localStorage -->
                                        <!-- JSON is a built in object thats similar to a javascript object but with less features -->
                                         <!-- All properties and strings in JSON has to be enclosed in double quotes  and it does not support functions -->
                                        <!-- Javascript syntax only makes sense in javascript, however, JSON syntax is universal and can be used in any language -->
                                          <!-- We also use JSON to store data in a file -->
                                          <!-- JSON is used to send data between computers -->
                                          <!-- Built-in JSON is used to convert javascript objects to JSON and vice versa -->
                                            <!-- JSON.stringify() is a method of the JSON object.ie. (it is a function (stringify) saved in an object (JSON))  and it is used to convert javascript objects to JSON -->
                                            <!-- inside the JSON.stringify() brackets, we can pass the javascript object and it will convert it to JSON -->
                                              <!-- JSON.stringify() actually results in a string -->
                                              <!-- To convert from a JSON string to a javascript object, we use JSON.parse() -->
                                                <!-- localStorage is a built-in object that is used to store data in a file/more permanently -->
                                                <!-- Variables are temporary and when we refresh our page , they are lost, however, localStorage is permanent and doesn't get deleted whe the page is refreshed -->
                                                  <!-- The syntax for saving into localStorage is localStorage.setItem('key','value'), where 'key' is the name of the property and 'value' is the value of the property -->
                                                  <!-- localStorage only accept strings -->
                                                    <!-- localStorage.getItem('key') loads the value of the property with the name 'key' that was saved in localStorage -->
                                                    <!-- you can console.log() the localStorage.getItem('key') to see the value of the 'key' saved -->
                                                       <!-- Something that doesn't exist in localStorage will return null -->
                                                        

                                                        <!-- SIDE NOTES -->
                                                         <!-- Null and undefined represent the absence of a value, however when we inset null into a function, we want to make the function empty unlike undefined which uses the default value if the parameter of the function has a default value -->
                                                          <!-- strings can also have properties eg . const name = 'John Doe' and name.length will return the length of the string -->
                                                           <!-- strings alo have methods eg. name.toUpperCase() will return the string in uppercase -->
                                                            <!-- OBJECTS are references -->
                                                             <!-- When we create an object, the properties along with the values gets saved somewhere in the memory of the computer, however, the object names itself is just a reference to the location in the memory where the object is saved -->
                                                              <!-- When we equate a variable to an object, we are equating the variable to the reference of the object which is the object name. this is called Copy by Reference  ie. const name = {key1:value1,key2:value2} and const name2 = name 
                                                               now, name and name2 are referencing the same object in the memory -->
                                                               <!-- Const prevents us from changing the reference of the variable, however, it doesn't prevent us from reaching into the reference and changing the properties of the object it is referencing -->
                                                                <!-- We cant compare objects directly ie.if two variables have the same objects that was stated explicitly, we can't compare them directly using the equality operator ie. if (name === name2). We are actually comparing their references not the objects they are referencing -->

                                                                <!-- SHORT CUTS -->
                                                                 <!-- const object = {message : 'hello'}
                                                                  const {message} = object; is the same as const message = object.message -->
                                                                  <!-- const object = {message : 'hello', price:799}
                                                                  const {message} = object; is the same as const message = object.message and
                                                                  const {price} = object; is the same as const price = object.price. they can be in the same line like this: const {message,price} = object -->
                                                                  <!-- const object = {method: function function1 (){console.log('happy')} can be written as const object ={ method(){console.log('happy')}  } -
                         
                                                                  
                                                                   
                        <!-- DOCUMENT OBJECT MODEL -->
                         <!-- DOM is a built -in object that represents the structure of the HTML document -->
                          <!-- document is a built in object provided by javascript -->
                           <!-- the document object and the web-page are connected ie. when we change the properties of the document object, the web-page changes and vice versa -->
                            <!-- the document objects represents /models the web-page -->
                             <!-- document.title gets the title of the web-page (into javascript)  and changing it changes the title of the web-page -->
                              <!-- document.body takes the body HTML elements of the web-page and puts it into javascript -->
                               <!-- the DOM combines the HTML and javascript on a page and gives javascript controls of the page -->
                                <!-- NB: if an HTMl is inside a javascript, it gets converted into a javascript object  -->
                                 <!-- document.body.innerHTML. Here, the innerHTML targets and controls all the HTML elements inside the body element and if it is changed, it changes the entire HTML elements inside the body element -->
                                  <!-- document.querySelector() lets us get any element from the page and put it into javascript.you can console.log() it or save it in a variable and then use it to change the properties of the said element -->
                                   <!-- Every html in javascript has an innerHTML property which lets us control the html in the element -->
                                    <!-- Every html in javascript has a remove() method which lets us remove the html in the element. in situations as such, its advisable to save the the element in a variable first before removing it -->
                                    <!-- a common practice when selecting  elements using the class attribute for javascript is to use "js-" before the class name to avoid conflicts with CSS -->
                                     <!-- HTML elements in Javascript are Javascript objects and since OBJECTS are just values, we an save them as variables and also you can use the innerHTML property to target the HTML of the element -->
                                      <!-- innerText doesn't mind the space between the text and the element, however, innerHTML does -->

                                      <!-- BIG DISCOVERY -->
                                       <!-- .js-score: This element is updated with the current score immediately when the page loads by calling the displayScore() function. The score is initialized based on the values retrieved from localStorage or defaults to zero if no score exists. -->
                                        <!-- .js-result and .js-move: These elements do not have any initial values set when the page loads. If you do not explicitly set their content, they will remain empty until the user interacts with the game (i.e., until a button is clicked and the playGame function is executed). -->

                                        <!-- Setting Initial Values: To ensure that .js-result and .js-move display meaningful content when the page loads, you need to initialize them with default values. In the revised code, we set: -->

                                        <!-- Dynamic Updates: After the user makes a move, the playGame function updates the content of .js-result and .js-move based on the player's choice and the computer's choice. This is why they only show meaningful content after a game is played. -->

                                        <!-- MAJOR DISCOVERY WITH REGARDS TO THE INPUT DOM CALCULATE SHIPPING -->
                                         <!-- User Experience: If you don't reset the messages, the user might see outdated information or error messages from previous calculations, which can be confusing. For example, if a user enters a valid cost after previously entering an invalid one, they should not see the old error message. -->

                                         <!-- Early Exit: The return statement immediately exits the calculateTotal function if the condition is met. This prevents any further calculations from being performed with an invalid cost. If you didn't return here, the function would continue executing, potentially leading to incorrect calculations or unexpected behavior. -->


                                        <!-- Whenever we get a value from the DOM like inputButton.value, its a string, so to covert into a number, we use the Number() function to manually convert it to a number -->
                                         <!-- Clicks and keydown are events whiles onclick and onkeydown are event listeners which check for events and execute javascript when the events occur eg of events and event listeners are : scroll-onscroll , click-onclick, keydown-onkeydown, mouseover-onmouseover (hovering) etc -->
                                          <!-- NB:Every event listener has an event(click/key) object which contains information about the event (click/key) that occurred. -->
                                           <!-- Using onkeydown = console.log(event); on an input,you can display the event(click/key) object with its properties including the key pressed, the key code, the location of the key pressed etc.  -->
                                            <!-- NB: if a string contains only numbers, and we (-*/), javascript automatically converts the string into a number, however, if we (+), javascript automatically converts it into a string -->

                                            <!-- when you use the + operator with a string and a number, JavaScript performs string concatenation by converting the number to a string. This is different from the increment operator (++), which always results in a numeric value when applied to a variable, even if that variable initially holds a string. -->

                                            <!-- HTML,CSS AND JAVASCRIPT -->
                                             <!-- Just like how all html elements in Javascript are Javascript objects which can be saved as variables, they also have properties like innerHTML,innerText, classLists. classlist is a property that gives us control over the class attribute of the element -->
                                              <!-- classList itself is an object which has methods like add(), remove(), toggle() etc. classList.add('value') adds a class called value to the element. Also classList.contains('class-name') checks if the element has a class called class-name -->



                        <!--ARRAYS AND LOOP -->
                        <!-- Array is another type of value in javascript which represent a list of values -->
                         <!-- Since they are just values, they can be saved in a variable  and they can be saved in other arrays-->
                          <!-- To get a specific value in an array, you can use the []bracket notation eg: MyArray[0] where MyArray is the name of the array and 0 is the index of the value you want to get -->
                           <!-- To change say the second value in ana array eg. MyArray[1] = 20 . this changes the second value in the array to 20 -->
                            <!-- The syntax for arrays eg [12,20,27,true,'hello'] and Since they are just values, they can be saved in a variable. their index starts from 0 -->
                             <!-- console.log(typeof [1,2]); results in object because ARRAYS ARE A SPECIAL TYPE OF OBJECTS in javascript -->
                              <!-- console.log(Array.isArray([1,2])); results in true and this checks if the value is an array -->
                               <!-- Since arrays are objects, they have methods and properties like length which gives us the number of values in the array -->
                                <!-- Arrays have methods like push() which adds values to Arrays eg. MyArray.push(20) adds 20 to the end of the array -->
                                 <!-- Arrays have methods like splice() which removes from Arrays eg. MyArray.splice(0,1) removes the first value in the array. Here, the "0" indicates where to start removing from and the "1" indicates how many values to remove -->

                                 <!-- THE SYNTAX FOR "WHILE LOOPS" -->
                                  <!-- loop variable ie let i = 0 ; is the variable that will be used to control the loop.
                                 while (loop condition){ loop body, increment step} where increment step is the variable that is incremented in each iteration of the loop -->

                                 <!-- SYNTAX FOR "FOR LOOPS" -->
                                  <!-- for (loop variable;loop condition;increment step){loop body} -->

                                  <!-- We use while loops for non-standard iterations of a loop. eg. when we don't know how many times to loop.We use for loops for standard iterations of a loop eg. when we know how many times to loop -->

                                  <!-- LOOPING THROUGH AN ARRAY -->
                                  <!-- Looping through an array means to go through the each value of an array one by one and doing something with each value -->

                                  <!-- SYNTAX FOR USING ACCUMULATOR PATTERN -->
                                   <!-- The accumulator pattern rules involve for 1. to create a variable to save the result 2. Loop through the array to update the result  -->

                                   <!-- Just like Objects are references, Arrays are references too -->
                                     <!-- When we create an array, the values gets saved somewhere in the memory of the computer, however, the array names itself is just a reference to the location in the memory where the arrays is saved -->
                                                              <!-- When we equate a variable to an array, we are equating the variable to the reference of the array which is the array name. this is called Copy by Reference  ie. const name = [value1,value2] and const name2 = name 
                                                               now, name and name2 are referencing the same array in the memory -->
                                    <!-- The only way to make sure that with the above example, if we push a value into name2, and we console.log both name and name2, both would not display equal values is to use slice. ie . const name2 = name.slice(). with this, name and name2 are referencing different arrays in the memory. the slice() makes sure name2 makes a copy of the array name is referencing in memory -->
                                     <!-- const [firstValue] = [4,66,74,53] . Here the first value(4) gets saved in a variable called firstValue-->
                                      <!-- loops also have break and continue statements. break stops the loop while continue skips the current iteration of the loop -->
                                       <!-- loops also have remainder statement. if you want the iteration to skip all values divisible by 3 ie. if(i % 3 === 0){continue;}. This will skip all values divisible by 3 in the loop -->
                                        <!-- if you want to skip all iteration with a remainder of 1 ,ie. if(i % 3 === 1){continue}. This will skip all values with a remainder of 1 in the loop -->
                                         <!-- in a while loop, if we want to make the continue statement effective we need to state the increment step manually ie before the continue statement . This is so to avoid skipping the increment step which is necessary for the loop to continue and to avoid the infinite loop -->
                                          <!-- We can utilize loops with functions and use parameters to try out different arrays eg. below -->
                                          <!-- function doubleArray(num){
                                            let doubledNumbers = [];
                                            for(let i = 0; i < num.length; i++){
                                                const numbers = num[i];
                                                doubledNumbers.push(numbers* 2);
                                            }
                                            return doubledNumbers;
                                          }

                                          console.log(doubleArray([8,4,2,3,4,5]));
                                          console.log(doubleArray([3,3,1]));  Here we used the loop on two different arrays and we got the expected results -->

                                          <!-- ADVANCED FUNCTIONS -->
                                           <!-- Functions themselves are values which can be saved in variables and passed as arguments to other functions. Since they are values, they do whatever values do -->
                                            <!-- If there's a way of accessing a function, its name is not needed.eg 
                                             const function1 = function greeting(){console.log('Hello');}.
                                             We can access the function by using the variable eg. function1() and with this, we can let go of the function name being 'greeting' -->
                                            <!-- A function without a name is called Anonymous function -->
                                             <!-- setTimeout() allows us to run a function in the future -->
                                              <!-- setTimeout is a built-in function and "()" means to call a function so setTimeout() is calling the setTimeout function -->
                                               <!-- setTimeout() takes two values. 1. the function we wish to run, 2. how long to wait before the function runs (in milliseconds) -->
                                                <!-- Asynchronous code means the computer doesn't wait for the function with a timer, to finish first before moving to other lines. It sets the timer, moves to the following lines to execute the codes up until the timer is done and then it runs the function with the timer -->
                                                 <!-- Synchronous code means the computer will wait to execute a line of code before it moves on. All the codes we have been writing so far are synchronous code -->
                                                  <!-- setInterval() takes the same syntax as setTimeout() however, with setInterval(), the function repeats after every timeout -->

                                                  <!-- MAJOR DISCOVERY WITH REGARDS TO THE AUTO-PLAY BUTTON IN ROCK,PAPER... -->
                                                   <!-- Initial Value: By initializing isAutoPlaying to false, you establish a clear starting point for the variable. This indicates that, at the beginning of your program, autoplay is not active.
Predictable Behavior: When the program starts, you know that the autoplay feature is off. This predictability is crucial for the logic that follows, as it allows you to make DECISIONS BASED ON THE CURRENT STATE OF THE FLAG. -->

<!-- Conditional Logic: The isAutoPlaying flag is used in conditional statements to determine whether to start or stop the autoplay. If it is not initialized, the behavior of these conditions could be unpredictable.
Avoiding Errors: If you try to use a variable that has not been initialized, it may lead to unexpected behavior or errors. For example, if you check an uninitialized variable in a condition, it may evaluate to undefined, which can lead to logic errors. -->

<!-- Setting isAutoPlaying to true: This indicates that the autoplay has started. It should only be set to true when you are starting the interval.
Setting isAutoPlaying to false: This indicates that the autoplay has stopped. It should only be set to false when you are stopping the interval. -->

<!-- another way to loop through an array is to use a method of an array called forEach(); This is actually the proper way to loop through an array. Inside the forEach() brackets, we pass a function with a parameter and the code to execute. The function within forEach() can contain multiple parameters-->
 <!-- const Array1 = ['make dinner', 'wash dishes','buy tickets']

    Array1.forEach(function(value,index){
      console.log(value);
      console.log(index);
    }) in this example, every value in the array is saved inside the parameter (with its index) and it is used to run the function -->
     <!-- return statement does the same thing in forEach() as continue does in for loop. It stops the execution of the function and moves to the next iteration -->
      <!-- const Array1 = ['make dinner', 'wash dishes','buy tickets', 'watch a movie','do the laundry']

    Array1.forEach(function(value,index){
      if(value === 'watch a movie'){
        return;
      }

      console.log(value);
      console.log(index);
    })  this will only print out the items in the array except 'watch a movie' -->

    <!-- arrow functions are shorter ways to create functions -->
     <!-- the syntax for arrow functions is const cheek = (parameter) => {code to execute}. you can call this function by using the variable name eg. cheek() -->
      <!-- arrow function works the same way as regular functions. It can take parameters, return values, and even have multiple parameters -->
       <!-- The shortcuts are these -->
        <!-- if an arrow function has one parameter, you can do away with the parentheses eg. const cheek = x => {code to execute} -->
         <!-- if you have a one line arrow statement, it returns the value at the right side eg.
          const cheek = () => 2 + 3;
          console.log(cheek()); // outputs 5 -->
          <!-- Whenever we want to pass a function into another function, its best to use arrow functions. This is because arrow functions are more concise and easier to read -->
           <!-- a shortcut for saving a function in an object eg.
            const object1 = {
            method(){}

            instead of method: function(){}
            } In saving a function into an object, it is recommended to use this instead-->

            <!-- AddEventListener() -->
             <!-- Every html element has a method called addEventListener() which allows you to attach an event listener to the element and it executes a function when the event occurs -->
              <!-- addEventListener() has two parameters. 1. what event are we to listen for and 2. what function are we to execute when the event occurs -->
               <!-- eg. document.addEventListener('click', () =>{console.log('document was clicked')}) . here the console .log is the function that will be executed when the document is clicked -->
               <!-- An advantage of addEventListener() is that it can be used to attach multiple event listeners to the same event -->
                <!-- removeEventListener() is used to remove an event listener from an element. the parameters are the same as addEventListener() however, the function to be used in the second parameter should be saved in a variable and then passed to removeEventListener() otherwise, the function will not be recognized-->

                <!-- BIG DISCOVERY -->
                 <!-- When you use an arrow function (or any function) directly in the addEventListener method, you are creating a new function instance each time. This means that the function you are trying to remove with removeEventListener is not the same instance that was added. -->
                 <!-- By defining the event handler function separately, you ensure that you are using the same function instance for both adding and removing the event listener. This is essential for removeEventListener to work correctly.ie. by defining the function, you give removeEventListener function the chance to actually reference the function you wish to remove-->

                 <!-- The fact that we can add multiple events listener to the same events as well as remove them is a big advantage of addEventListener() over the onclick attribute  and highly recommended to use addEventListener() over the onclick attribute -->

                 <!-- BIG DISCOVERY -->
                  <!-- The parentheses () after playGame('rock') mean that you are calling the function right away. This means that the function runs immediately when the code reaches this line, not when the button is clicked. You can wrap the function call in an arrow function. This way, you are telling the button to call playGame('rock') only when it is clicked -->
                   <!-- By using an arrow function or a named function, you are delaying the execution of playGame('rock') until the button is actually clicked. This means the button knows what to do when it is clicked. -->

                   <!-- BIG DISCOVERY -->
                    <!-- Without the event parameter, you cannot access properties like event.key, which means you won't know which key was pressed.
 -->
                    <!-- The conditional statements that check for specific keys (like 'r', 'p', or 's') would not be able to execute, as there would be no way to evaluate the key pressed. -->

                          <!--filter() creates an array , and it returns true if the condition is met which gets put in the new array  and returns false if it is not met which gets left out of the new array -->
                    <!-- filter() is a method of an array. it works similar to forEach () as it requires parameters to  loop through an array and makes a new array with the items that meet the condition. -->
                     <!-- eg. console.log([1,-1,3].filter((value,index) =>{
                      if (value > 0){
                            return true}else{
                            return false}
                            })).  this will return [1,3]  in the console-->

                            <!-- shortcut is eg. console.log([1,-1,3].filter((value,index) =>{
                             return value >= 0;
                            })).  this will return [1,3]  in the console-->  

                    <!-- map() creates an array, whatever is returned gets added to the new array -->
                     <!-- map() turns an array into a new array depending on the return value -->
                     <!-- map() is a method of an array. it works similar to forEach() as it requires parameters to loop through an array -->
                      <!-- eg console.log([1,1,3].map((value,index) =>{
                       return value* 2})). this returns [2,2,6] in the console -->
                       <!-- the shortcut for the code above is [1,1,3].map(value => value*2) -->

                       <!-- Data attribute is just an html attribute that starts with data- and helps us attach any information to an html element eg. data-product-name = "product name" -->
                        <!-- dataset is a property of an html element that allows us to access the data attributes that are attached to the element.ie. to get the value of the data-product-name attribute, we reach into the element, then into the dataset, then into the data-product-name property eg. console.log(button.dataset) will reveal an OBJECT with the DATA ATTRIBUTES of the button AND console.log(button.dataset.productName) will reveal the value of the data-product-name attribute;-->


                        <!-- MODULES -->
                         <!-- Modules are better ways to organize your codes. -->
                          <!-- Having scripts stacked on top of each other can be confusing and hard to manage since it acts like a big pile of code. its very difficult to ascertain what variables have already been declared in what scripts and what has not. its also easy to commit naming conflicts since you are working with a big pile of code. -->
                           <!-- A module contains a set of related functions and variables in a file,that can be used by other scripts and not cause naming conflicts with anything outside the file. -->
                            <!-- Syntax for creating a module. 1. create a file 2.Don't load the file with <script>. NB: Any variable or function created within the file stays in the file -->
                              <!-- To get a variable/function outside a file, 1. You use the type = "module" attribute on the script which would be accepting the importation. 2. You use the export statement to export the variable/function from the file you wish to import from  3. You use the import statement to import the variable/function on the script that is accepting the importation -->
                               <!-- type = "module" attribute makes the script a module.ie. it lets this file get variables /functions from other files -->
                                <!-- export const cart = [...]; exports the cart variable from the file -->
                                 <!-- import {cart} from '../data/cart.js'; this imports the cart variable from the cart.js file . the "." gets us out of the current folder/file into the parent folder/file -->
                                  <!-- With modules, you have to put all import files at the top of the code editor  -->
                                   <!-- We need to use live server to make our modules work -->
                                    <!-- One major benefit of using modules is that you don't have to be concerned about the order of our other script files as we'd just be importing the variables that are only important to us -->


                                  <!-- EXTERNAL LIBRARY -->
                                   <!-- External library is a code outside of our project -->
                                    <!-- We can load an external library by using a script tag with its src being the location of the library. If its necessary to use an external library, its script tag should be on top of all other script tags -->
                                     <!-- a default export is another way of export when we want to export only one thing from a file. -->
                                      <!-- eg. export default formatCurrency. in the module file, you import without the parenthesis -->
                                       <!-- NB: dayjs() only exports one function "dayjs()" so we can use the default export to import it -->
                                        <!-- ESM version of any external library is that version that works with Javascript modules. it stands for EcmaScript. -->
                                         <!-- ESM version for dayjs() is dayjs and not dayjs() -->

                                         <!-- The technique we used where when we update our data in javascript, we regenerate the html for the date is called MVC ie . Model View Controller -->
                                          <!-- in MVC, we split our code into three parts: Model, View, and Controller . Model = saves and manages the data(cart.js,products.js,deliveryOptions.js). View =takes the data and displays it on the page(checkout.js,amazon.js). Controller = runs some code when we interact with the page eg(addEventlisteners which makes the page interactive when we click something on the page) -->
                                           <!-- MVC interact with each other ie. View takes the model/data and generates HTML which it previews. Controller runs when the display is interacted with,then the controller updates the model/data which necessitates an update of the html/view to fit the new data -->

                                           <!-- NB: in the file path when importing, ../ means go out of your parent directory while ./ means to get out of your current directory into the parent directory -->


                                           <!-- AUTOMATED TESTING -->
                                            <!-- Using code to test code. its useful to use automated testing other than manual testing which requires opening the browser to ascertain if the code is working as expected. Manual testing takes a lot of time and is prone to human error. -->
                                             <!-- There are two types of test cases. 1. basic test case: it checks if your code is working. 2.Edge cases: Check with values that are tricky -->
                                              <!-- in test cases, make sure to have both basic and edge test cases -->
                                               <!-- Testing Framework is just an external library that helps us write code easier eg. jasmine,mocha stc. in jasmine "spec" is the same as "test"  -->
                                                <!-- integration testing is when we test how different parts of our code interact with each other. -->

                                               <!-- JASMINE FRAMEWORK -->
                                                <!-- in jasmine , we create a test suite with a function called describe(). it has two parameters. 1. the name of the suite in strings. 2. a function that contains the test cases. in that function , we use it() to create a test case. however, it() has two parameters being 1. the name of the test case in strings. 2. a function that contains the test case. -->
                                                 <!-- in the test case function, we use expect() to check if the result of the code is what we expect.expect() creates an object and has many methods like toBe(), toEqual(), toContain(),toHaveBeenUsed() etc. -->
                                                  <!-- FLAKY TEST: a test that sometimes passes and sometimes fails even if we don't change the code -->
                                                   <!-- Mocks: a mock lets us replace a method with a fake version and we can use the fake version however we want -->
                                                    <!-- to mock, we use spyOn(). spyOn() takes two parameters. 1. the object it wishes to  mock (eg.localStorage) and the method it wants to mock,in quotes (eg 'getItem').This clones the localStorage.getItem.--> <!--spyOn() use properties like ".and" which in turn has properties like "callFake". in all eg. spyOn(localStorage,'getItem').and.callFake(() => {return []});. This makes the cloned localStorage.getItem return whatever gets put in the curly bracket and in this instance an empty array -->
                                                     <!-- sypOn() has a feature that records every time a method is used.ie.spyOn().toHaveBeenCalledTimes()-->

                                                     <!-- When we are testing a page, there are two things we need to consider. 1.How the page looks 2.How the page behaves -->
                                                      <!-- With regards to how the page looks, we have to do the basic test first.ie.testing what the function does -->
                                                       <!-- then we get to the other functionalities of function  -->

                                                      <!-- BIG DISCOVERY: You can use code to click an element and this is done by getting the element first into javascript by DOM, then using the "click()" method on it -->

                                                      <!-- OBJECT ORIENTED PROGRAMMING (OOP) -->
                                                       <!-- It is just another way of programming/writing code. It is basically organizing our code into object -->
                                                        <!-- in procedural programming, we organize our codes into functions however in OOP, we organize our codes into objects-->
                                                         <!-- OOP replicates the real world. ie, in the amazon project, we use OOP to replicate the cart in the real world and the events thats likely to modify it eg. adding or removing from the cart, changing your delivery option etc-->
                                                          <!-- OOP makes it easy to create multiple objects -->
                                                           <!-- NB: in OOP, the naming convention for things that create or generate objects are always in PascalCase -->
                                                            <!-- we can use function to create/generate multiple objects.ie. we can use functions eg. function Cart () to host objects we want to replicate so whenever, we call the function, a new object is created. this is better than copying entire pieces of code and pasting them to create objects -->

                                                        <!-- BIG DISCOVERY: let cart; means cart = undefined; -->
                                                         <!-- ALSO: "this" is a feature of javascript that gives us the object which contains the function so it doesn't matter if we have change of object name's later, "this" would always capture the object. we use "this" inside the object not outside -->

                                                         <!-- OOP has a feature specifically for generation objects. its called "class". A class is an object generator -->
                                                          <!-- in OOP, class uses a similar syntax as a function(when calling it) however, it has "new" in front of it -->
                                                           <!-- we create a class by eg. class Cart {} which we load it up with properties and methods and every time we create/generate an object using the class.eg. new Cart (), we get access to every property and method available in the class -->
                                                            <!-- an object generated from a class is known as an "instance" of the class.if eg. businessCart is an object from a class called Cart, then console.log(businessCart instanceof Cart); will display true in the console -->
                                                             <!-- a constructor lets us run a setup code after creating an object. it helps us put the the setup code inside the class which makes our code look cleaner -->
                                                              <!-- One important feature of using the constructor is that once you generate an object,it runs automatically to generate the object -->
                                                               <!-- NB: the constructor of a class can hold a parameter and its object can access that through the "()" of the created object eg, cart = new Cart (value) -->
                                                                <!-- Classes has features which makes a property/method private ie. it can only be accesses inside the class.This feature is "#". You put "#" in-front of any property/method and it becomes private -->

                                                                <!-- CONVERTING AN OBJECT INTO A CLASS -->
                                                                 <!--Eg.In products.js, instead of using the objects in the array, we'd be converting all the ordinary objects into a class  -->
                                                                 <!-- NB: map() is a method of an array which loops through the array and for each value, it runs a function. Also,Map() produces a new array and whatever gets "return" gets added to the new array-->

                                                                 <!-- INHERITANCE -->
                                                                  <!-- Inheritance lets us reuse code between classes -->
                                                                   <!-- To use inheritance, after the class name,we state "extends" and the class we wish to inherit from. this will make the child inherit all the properties and methods of the parent  -->
                                                                    <!-- We use inheritance when we have one class which is a more specific typeof another class and in order to avoid duplication of one class' properties and methods, we use inheritance so a class could possess the properties an another another class -->
                                                                     <!-- We call the exporting class "Parent class" and the importing class "child class" -->
                                                                      <!-- Even though the child inherits the properties and methods of the Parent, in the constructor, we need to set these values. However we can bypass that by declaring the constructor in the parent class. We do this by calling a special feature of classes called "super(parameter)"."super(parameter)" basically calls the constructor of the parent class and all the defined attributes in them -->
                                                                       <!-- the child class too can have specific attributes exclusive to it -->
                                                                       <!-- If we fail to set up a constructor in the child,it automatically uses that of the parent -->

                                                                       <!-- BUILT IN CLASSES -->
                                                                        <!-- Built in classes are classes that are provided by the language eg.Date() -->
                                                                        <!-- new Date()- generates an object that represents the current date -->
                                                                         <!-- dayjs() is preferred to this because of the extra features it possess -->
                                                                        <!-- NB:Global Scope: When you are in the global scope (i.e., not inside any function or object), "this" refers to the global object. In a browser environment, the global object is the window. In Node.js, it is global.In the console,"this" will return as undefined. the same applies to the second example as "this" will not reference "object2" but the global variable which doesn't have a variable "a" defined.Same for eg 4-->
                                                                         <!-- console.log(this)= undefined; -->

                                                                          <!-- const object2 = {
                                                                          a:2,
                                                                          b:this.a
                                                                        }
                                                                          console.log(object2.b)= undefined;"this" points a global variable which doesn't have a defined a."this" has to be in a function or method inside a class for it to work-->

                                                                          <!-- const object3 = {
                                                                          method:() => {
                                                                            console.log(this);
                                                                          }
                                                                          }
                                                                          object3.method()= undefined; "this" ideally should point to object3 but it'll point to the object outside which is the global class in this case and this is because,arrow functions do not change the behavior of "this". "this" retains the value it had outside the arrow function. in this context, "this" is points to a global variable like eg.1
                                                                          
                                                                          However, in this example eg
                                                                          const object3 ={
                                                                          method(){
                                                                            console.log(this);
                                                                          }

                                                                          [1,2,3].forEach(() => {
                                                                            console.log(this);
                                                                          });
                                                                          both "this" points to object3
                                                                          } .if the arrow function was a normal function,"this" would act just like it was independently created without a class and hence would be undefined.NB: arrow functions do not change the behavior of "this". "this" retains its value outside the arrow function-->

                                                                          <!-- function logThis(){
                                                                          console.log(this)
                                                                          }
                                                                          logThis()= undefined. the function is not in any object so "this" points to the global variable -->
                                                                           <!-- with regards to the last eg.4 "this" has a special method ".call()" which can help change the value of "this" to any value. eg. logThis.call('hello') actually runs the function and does the same thing as logThis(),however, it returns 'hello' in the console -->

                                                                           <!-- REACT -->
                                                                            <!-- React is an open source library for building user interfaces.React is a javaScript library not a framework and its sole purpose is to help build user interfaces -->

                                                                             <!-- NB:A framework is a structured platform or set of tools that provides a foundation for building software applications. It offers a predefined way to organize code, manage dependencies, and implement common functionalities, allowing developers to focus on the unique aspects of their applications rather than reinventing the wheel for every project.eg.frontend frameworks eg. React,Angular,Vue. Backend frameworks eg.Node.js,Python.Testing frameworks eg.Mocha,jasmine -->
                                                                              <!-- rules to creating a react app. 1. copy syntax from "vite.dev" and run it in the terminal 2.follow the process and create the react app 3. open the folder through vs code and open terminal 4. enter "npm install" then "npm run dev"-->
                                                                               <!-- if you close your terminal or browser and you want to link your react to the browser, you need to use "npm run dev"-->
                                                                                <!--  The React app is injected into this HTML file(index.html), typically within a <div> with the ID of root. -->
                                                                                  <!-- Purpose of main.jsx

Application Entry Point: The main.jsx file is the first JavaScript file that runs when your React application starts. It is responsible for rendering the root component of your application.

Rendering the App: It typically uses the ReactDOM.render() method to render the main component (often called App) into a specific DOM element, usually a <div> with the ID of root in the index.html file.

 -->
  <!-- ReactDOM.render(): This method takes two arguments: the component to render (in this case, <App />) and the DOM element where it should be rendered (document.getElementById('root')).
Wrapping the <App /> component in <React.StrictMode> is optional but recommended during development. It helps identify potential problems in your application. -->
  <!-- App.jsx -  typically serves as the main component of your application. It is where you define the structure and behavior of your app's user interface. It serves as the root component that is rendered in the main.js file. It defines the overall layout and structure of your application, including headers, footers, and main content areas -->
   <!-- The className attribute is used to apply CSS styles -->
    <!-- The App component is exported as the default export, allowing it to be imported in other files (like main.js). -->

    <!-- Difference between index.css and App.css. ./index.css: A CSS file for global styles.eg.header tags,anchor tag,body,etc ./App.css: A CSS file for styles specific to the App component.eg. header component.main component,footer component -->
     <!-- In react,a component refers to a part of the user interface -->
      <!-- App is the component that contains all other components. It is also known as the root component -->
       <!-- components are also reusable.ie. they can be used with different properties to display different information.Component codes are usually placed in javascript files eg. App component is placed in the App.jsx file so basically, components are codes inside a js file -->
        <!-- React has two types of components i.e. Stateless functional Component and Stateful class component  -->

         <!-- Functional Components:are a type of React component that are defined as JavaScript functions. They are used to render UI elements and can accept props (properties) as arguments. Unlike class components, stateless functional components do not manage their own state or lifecycle methods. Instead, they focus solely on rendering the UI based on the props they receive.Basically, functional components optionally receive inputs of properties(props) and return jsx/html that describes the UI. Now,you can use the useState and useEffect hooks to add state and lifecycle-like behavior to functional components -->

          <!-- 
         import React from 'react';

// A functional component that receives props
const Greeting = (props) => {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
    </div>
  );
};

// Usage of the Greeting component
const App = () => {
  return (
    <div>
      <Greeting name="Alice" />
      <Greeting name="Bob" />
    </div>
  );
};

export default App;
          -->
<!-- BREAKDOWN OF THE EXAMPLE -->
 <!-- Component Definition: The Greeting component is defined as a function that takes props as an argument. It returns JSX that renders a greeting message.

Props: The name prop is passed to the Greeting component when it is used in the App component. The component uses this prop to display a personalized greeting.

Usage: The Greeting component is used twice in the App component, demonstrating how it can be reused with different props -->
<!-- NB:rafce creates a default functional component set up -->

<!-- Here’s a simple example of managing state in a functional component using the useState hook: -->
 <!-- 
import React, { useState } from 'react';

const Counter = () => {
  // Initializing state with useState
  const [count, setCount] = useState(0);

  // Function to handle button click
  const increment = () => {
    setCount(count + 1); // Updating state
  };

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={increment}>Click me</button>
    </div>
  );
};

export default Counter;
 -->

<!--CLASS COMPONENTS: They are regular ES6 classes that "extends" the "component" class from the React library.They must contain a "render method" which in turn returns html/jsx.A class component can maintain a private internal state.ie. it can maintain some information which is private to that component and use that information to describe the user interface -->
<!-- 
import React, { Component } from 'react';

// A class component that manages its own state
class Counter extends Component {
  constructor(props) {
    super(props);
    // Initializing state
    this.state = {
      count: 0,
    };
  }

  // Method to increment the count
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  // Lifecycle method that runs after the component mounts
  componentDidMount() {
    console.log('Counter component mounted');
  }

  // Lifecycle method that runs before the component unmounts
  componentWillUnmount() {
    console.log('Counter component will unmount');
  }

  // Render method
  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={this.increment}>Click me</button>
      </div>
    );
  }
}

// Usage of the Counter component
const App = () => {
  return (
    <div>
      <Counter />
    </div>
  );
};

export default App;
-->
<!-- BREAKDOWN OF EXAMPLE -->
 <!-- 
Component Definition: The Counter component is defined as a class that extends React.Component.

Constructor: The constructor initializes the component's state using this.state. The super(props) call is necessary to access this.props in the constructor.

State Management: The component has a count state that tracks the number of times the button has been clicked.

Increment Method: The increment method updates the state using this.setState(), which triggers a re-render of the component.

Lifecycle Methods:

componentDidMount(): This method is called after the component is mounted to the DOM. It can be used for side effects like fetching data.
componentWillUnmount(): This method is called just before the component is removed from the DOM. It can be used for cleanup tasks.
Render Method: The render() method returns the JSX that defines the UI of the component.
 -->
<!-- PROPS(PROPERTIES):It is the object that contains the properties that has been passed from the parent component.It is the option of input that your component can accept.It also allows your component to be dynamic.To specify props for a component (in App) we specify them as attributes.-->
 <!-- Sometimes you might not know as to what content is being passed in a component (in App) but you'd want the component file to render such content. We can do that by specifying the content within the closing and opening tag of the component (in app) and retrieving it in the props object made available in the component file using {props.children} -->
 <!-- 
function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <Greet name="John" heroName= "Batman">
          <p>hello suckers,this is children props</p>
        </Greet>
      </div>
      
    </>
  )
}

export default App

const Greet = (props) => {
return(
  <div>
    <h1>Hello {props.name} a.k.a,{props.heroName}</h1>
    {props.children}
  </div>
)
}


export default Greet;
 -->
<!-- for props we know are to be passed, we should pass them as attributes. props we don't know /dynamic html syntaxes should be passed in the component's opening and closing tag and in the component definition, render them using  {props.children} -->
 <!-- NB: a jsx wrapper should only contain on element.This means that when you return JSX from a component, all the elements must be enclosed within a single parent element. -->
  <!-- Unlike functional components where we specify the props with the "props" parameter, we specify the it with "this.props" and it is reserved for class components  -->
   <!--  When we say that props are immutable, it means that once a component receives its props, it cannot modify them. ie modifying a props property in a component file will result in an error -->


      <!-- BRO-CODE -->


  <!-- NB:if you are sending a value=key as a prop and its not a string, it should be encased in an "{}". eg,
        const App = () => {
        <student age={15} name="Abigail"/>
        } 
        -->
        <!-- with booleans its best to use a ternary operator when defining them in their respective component eg.
        const student = (props) => {
        <p>{props.isStudent ? 'Yes' : 'No'}</p>
        } 
        -->

        <!-- PROP-TYPES -->
        <!-- PropTypes: its a mechanism that ensures that the passed value is of the correct type eg. age = PropTypes.number.ie. we want to ensure if the data passed (to age) is of the correct type(a number).Using prop-types would not stop the application from running if the criteria is not met, it'll just issue a warning within the console. -->

        <!-- DEFAULT PROPS -->
         <!-- defaultProps: a default value for props in case they are not passed from the parent component -->

         <!-- Conditional Rendering: it allows you to control what gets rendered in your application based on certain conditions (show,hide or change components) -->
          <!-- eg.
          const UserGreeting = (props) => {
          return(props.isLogged ? <h2>Welcome back , {props.username}!</h2> : 
                                    <h2>Please log in {props.username}</h2>)} 

          -->

           <!-- REACT HOOK -->
         <!-- Its a special function that allows functional components to use React features without writing class components. (useState,useEffects,useContext,useReducer) -->

         <!-- USE-STATE -->
          <!-- a react hook thats allows the creation of state variables and functions to update them. -->
           <!-- eg const [count,setCount] = useState(0). in this example , count is the state variable and setCount is the function to update it. setCount updates the count and saves it to the state variable "count". -->

           <!-- OnCHANGE: onChange event handler is primarily with form elements eg. <input>,<textarea>,<select>. it triggers a function anytime the value of the input changes -->

            <!-- NB: in applying internal css to an element in react, you'd have to enclose them in two objects. the first {} tells us its a jsx expression. the second {} is an object literal which expresses {property: value}.Note: properties uses CamelCase not dashes ie. backgroundColor not background-color. -->

            <!-- UPDATER FUNCTION -->
             <!-- a function passed as an argument to setState() usually  -->
              <!-- inside say an increment function eg -->
               <!-- 
              const increment = () => {
                setCount(count + 1)
                 setCount(count + 1)
                  setCount(count + 1);
                  , the result will be 1 instead of 3. this is because, the setCount() function is asynchronous and it doesn't update the state immediately. it batches the updates and applies them at once. to fix this, we can use an updater function which takes the previous state as an argument(parameter) and returns the new state. eg
                  setCount((prevCount) => prevCount + 1);
                }
               -->
                <!-- with the updater function, we are taking the pending state to calculate the new state.we update the current state with the last pending state. when using updater function, react puts all the updater functions in a queue waiting to be completed one after the other -->
                 <!-- its a good practice to use updater functions even when you are updating the state just once -->

                 <!-- NB: When you see something like ...c, it means: Take all the values (or properties) inside c and "spread" them into a new array or object. -->
                  <!-- 
                 const c = { name: 'John', age: 30 };
                      const newObj = { ...c, age: 31 };
                      // Result: { name: 'John', age: 31 }

                  -->
                  <!-- also when you have a "{}" after an "=>" javascript assumes we want to write a multi line statement but in this case we are trying to create an object eg.  -->
                   <!-- 
                  setFormData(prev => ({
                                      ...prev,
                                      email: 'test@example.com',
                                    }));
-->



     
   <!--DIFFERENCE BETWEEN PROPS AND STATE  -->
   <!-- Props get passed on to component whiles state exist in the component.Also, props are like function parameters while state behave like variables declared in a function body.again,props are immutable whiles states can be changed.We access props in function components as "props" and in class components as "this .props". We access state in functional components as useState-Hook and in class components as this.state-->
    <!-- a state is an object that is privately maintained in a component.A state can influence what is rendered in a browser, and finally a state can be changed within the component -->

     <!-- STATE -->
      <!-- with regards to components, if you render a component in app.jsx and you want to make adjustment to where when we click a button, the text changes, you can't pass them as props in App.jsx as props are immutable.ie.(once you pass them in App.jsx, thy cant be changed in the component definition). its best to use state which can influence what is rendered in a browser,and also a state can be changed within the component -->
       <!-- in using component state, the first step is to use a "this.state" and initialize it. "this.state" is used inside the class component. we define a constructor wih super() defined in it.Since our component "extends" from the React Component, super() must be stated so it realizes and copies the attributes of the constructor from the React Component .inside the constructor we initialize the "this.state". we link it similar to how we render props. in a curly bracket {} inside the render(). we create a button and set its onClick attribute to the method meant to change the initial text rendered. the method meant to change the text possess "this.setState()" which accepts a object describing the new state of the object which is to be enacted upon its call -->
        <!-- the eg
        import React,{Component} from "react";


class Message extends Component {
  constructor(){
    super();
    this.state = {
      message: 'Welcome friend'
    }
  }

  changeMessage(){
    this.setState({
      message: 'Thanks for subscribing'
    })
  }


  render(){
    return (
      <div>
        <h1>{this.state.message}</h1>
        <button onClick={() => {this.changeMessage()}}>Subscribe</button>
      </div>
    )
  }
}

export default Message; 
        -->
<!-- "this.state" can only be used in the constructor. any intention to change the state, setState must be used -->
 <!-- in situations within your application where you want some block of code to run after your "this.state" has been changed,you can pass that code as a callback to the "setState" method. the "setSate" has two parameters.ie. the "state" object (describes the new "state") and second, the callback function(gets passed after state is set) which is passed in an arrow function   -->
  <!-- 
 incrementCount(){
    this.setState({
      count: this.state.count + 1
    },() => {
      console.log('Callback value',this.state.count);
    })

    console.log(this.state.count);    
  }
 here, the console.log outside the "setState" returns 0 first before any increment. the callback returns 1 first and then the increments -->
 <!-- NB:If you need to execute some codes after the "state" has been changed,do not pass that after the setState method but rather pass the code within the callBack function which is placed as a second parameter to the setState method -->
  <!-- if you have to update the state based on the previous state,you'd have to pass it as a function(props) for the argument instead of the regular object -->

  <!-- HOW TO LINK TAILWIND TO REACT -->
   <!-- You first visit the tailwind documentation and copy the link to reference tailwind in your folder's terminal -->
    <!-- copy link to reference tailwind in config.vite *2 -->
     <!-- copy link to reference tailwind in index.css -->
      <!-- run npm run dev in vs code terminal of the folder -->

      <!-- HOW STATES AND SET-STATE WORKS eg. WITH FORM -->
       <!-- with respect to input, its controlled in react ie. the input in react are connected to a state. the "value" proposition of the input is taken as the state of the input   -->
        <!-- in situations, we set the state of the value to the input to an empty string. however, in our quest to change it to whatever would be typed into the input, we'd have to set the "ONchange" attribute of the input into a function say "handleNameChange()". the function "handleNameChange" should have an "event" parameter,reaches into the "event" object to get another "target" object, and finally reach into that object to get "value" property which gets the keys input into the input. We wrap this in the setName() which is meant to alter the state -->

        <!-- NB:The .trim() method returns a new string with whitespace removed from the beginning and end of the original string. It does not modify the original string, as strings in JavaScript are immutable.     -->
         <!-- eg
         let str = "   Hello, World!   ";
          let trimmedStr = str.trim();
          &nbsp;
          &nbsp;

          console.log(trimmedStr); // Output: "Hello, World!"
          console.log(str);        // Output: "   Hello, World!   " (original string remains unchanged) 
         -->
          <!--  Users may inadvertently add extra spaces before or after their input or not enter any input whatsoever. For example, a user might enter their name as " John Doe ". If this input is not cleaned, it can lead to inconsistencies in how data is stored and displayed. if the user doesn't enter any input, the state will be an empty string which can also lead to inconsistencies. to avoid this , we use the trim() method to remove any leading or trailing whitespace from the input. we also the "if" condition to check if the input is not empty before setting the state. this is to avoid the state being an empty string.  -->

          <!-- DESTRUCTURING -->
           <!-- Destructuring allows us to extract values from arrays and objects and assign them to variables in a convenient way. We use "[]" to perform array destructuring and "{}" to perform object destructuring.  -->
             <!--It can be used to swap the values of two variables. Example 1  -->
             <!-- 
             let a = 1;
              let b = 2;

              [a,b] = [b,a]
              console.log(a);
              console.log(b);
              -->

              <!-- Note, in this regard,the first array/object does the destructuring whiles the second array/objects does the assignment and saves the result to a variable. -->

              <!-- it can be used to swap two elements in an array -->
               <!-- 
              const colors = ["red", "green", "blue", "yellow", "purple", "orange"];

              [colors[0],colors[5]] = [colors[5],colors[0]]

              console.log(colors)
               -->


              <!-- It allows us to assign array elements to variables -->
               <!-- const colors = ["red", "green", "blue", "yellow", "purple", "orange"];

              const [firstColor,secondColor,thirdColor,...extraColors] = colors;

              console.log(firstColor); returns "red"
              console.log(thirdColor); returns "blue"
              console.log(extraColors)  returns ["yellow", "purple", "orange"] -->


              <!-- it allows us to extract values from objects -->
               <!-- 
              const person1 = {
                    firstName:'Mark',
                    lastName:'Anthony',
                    age: 30,
                  }

                  const {firstName, lastName, age, job = "unemployed"} = person1;
                  console.log(firstName);
                  console.log(lastName);
                  console.log(age);
                  console.log(job);
               -->
                  <!-- NB: we can set a default property when destructuring -->

                  <!-- it allows us to destructure in function parameters -->
                   <!-- 
                 function displayObject ({firstName,lastName,age,job}){
                    console.log(`name: ${firstName} ${lastName}`);
                    console.log(`age: ${age}`)
                    console.log(`job: ${job}`)
                  }


                  const person1 = {
                    firstName:'Mark',
                    lastName:'Anthony',
                    age: 30,
                    job: 'Software Engineer',
                  }

                  displayObject(person1);
                   -->

                   <!-- USE-EFFECT() -->

                    <!-- RE-RENDERING: In React, when we say that a component "re-renders," we are referring to the process where the component is updated and its output is recalculated and re-rendered in the DOM.When a component's state is altered either using useState hook(functional components) or setState method(class components)or If a component receives new props from its parent component, React schedules a re-render of that component. This is because the UI needs to reflect the new state. -->
                     <!-- MOUNTED: when a component is mounted, it is executed, and the resulting JSX is converted into actual DOM elements, which is then rendered on the page. This is a fundamental part of how React works, allowing it to create dynamic and interactive user interface -->

                     <!-- NB:State updates in React are asynchronous so if you need to perform an action based on the updated state, you can use the useEffect hook or pass a function to the state updater that takes the previous state as an argument. -->

                     <!-- UseEffects(): React Hook that tells React to do some code when 1.This component re-renders. 2.This component mounts 3. the state of a value passed in the component changes  -->
                      <!-- 1.useEffects(() => {})  Runs after every re-render -->
                       <!-- 2.useEffects(() => {}, [])  Runs only once after the component mounts -->
                        <!-- 3.useEffects(() => {}, [value])  Runs only when the value changes -->

                        <!-- RETURN IN USE-EFFECT -->
                         <!-- In React, the return statement in the useEffect hook is used to define a cleanup function that runs when the component unmounts or before the effect runs again due to dependency changes. -->
                          <!-- Its best practice to use a cleanup function remove addEventlisteners or other events before the component unmounts or re-renders(if no dependency is provided) to prevent unexpected behavior. -->
                          <!-- On Component Unmount: The cleanup function is called when the component is removed from the DOM. This is crucial for cleaning up resources like event listeners or subscriptions.
                          Before Re-running the Effect: If the dependencies of the useEffect change, the cleanup function from the previous render is executed before the new effect runs. This ensures that the previous effect is properly cleaned up before applying the new one. -->


                    <!-- NB:  In JavaScript, when using curly braces {} in an arrow function, you need to explicitly return the value. If you want to return a JSX element, you can either use parentheses () or add a return statement. -->

                    <!-- WITH REGARDS TO THE C-R IN CRUDE -->
                     <!-- Component Responsibility: Each component should have a clear responsibility. The User List component is responsible for rendering a list of users, while the User Item component is responsible for rendering the details of a single user. By passing the user data as props, you maintain a clear separation of concerns. -->

                     <!-- USE-CONTEXT() -->
                      <!-- useContext() = React hooks that allows you to share values between multiple levels of components without passing props down through each level -->
                       <!-- PROVIDER COMPONENT -->
                        <!-- 1. import {createContext} from react -->
                         <!-- 2.export const myContext = createContext() -->
                          <!-- 
                         <myContext.Provider value={value}>
                              <Child/>
                          <myContext.Provider/>
                          -->

                          <!-- CONSUMER COMPONENT -->
                           <!-- 1.import React {useContext} from 'react' -->
                            <!-- import {myContext} from './ComponentA' -->
                             <!-- const value = useContext(myContext) -->

                             <!-- NB: any child component of the provider can use the context value -->

                             <!-- USE-REF() -->
                              <!-- Use-State() = Re-renders the component when the state value changes -->
                               <!-- Use-ref() = "use-reference" does not cause re-renders when its value changes.UseRef() returns an object with a single property,"current" and whatever gets put inside the useRef() becomes the initial value of the "current" property. the property can hold, an array, an object,a value, an html element and it doesn't re-render when the value of the "current" property changes  -->
                                <!-- where use-ref() is most useful
                                 1.accessing/Interacting with DOM elements
                                 2. Handling Focus,Animations and transition 
                                 3. Managing Timers and intervals-->
                                 <!-- UseRef() returns an object with a single property,"current" and whatever gets put inside the useRef() becomes the value of the "current" property -->

                                 <!-- Updating a value stored in a ref does not trigger a re-render of the component. This makes useRef suitable for storing values that you want to keep around but do not need to display in the UI. -->

                                 <!-- NB:
                                 Use useState() when you need to manage state that affects the rendering of your component.
                                Use useRef when you need to access a DOM element directly or store a mutable value that does not require re-rendering when it changes.
                                 -->

                                 <!-- NB: The ref in an <input> (or any React element) is a way to directly reference that DOM node so you can interact with it imperatively—without relying solely on React's state or props. this can allow manipulation of the input's properties. -->

                                 <!-- STEPS TO APPLY SVG IN REACT -->
                                   <!-- npm install vite-plugin-svgr --save-dev -->
                                  
                                     <!-- 
                                    // vite.config.js
                                    import { defineConfig } from 'vite';
                                    import react from '@vitejs/plugin-react-swc';
                                    import svgr from 'vite-plugin-svgr';
                                    export default defineConfig({
                                      plugins: [react(), svgr()],
                                    });

                                     -->
                                    <!-- import { ReactComponent as MyIcon } from './assets/my-icon.svg'; -->


                                    <!-- API's -->
                                     <!-- Asynchronous calls -  functions/commands that run on the background and hence does not interrupts with the main application flow.

                                     JSON - A structured text of key-value pairs used in network communication.

                                     Promises - represents a value that is not available yet, but will be resolved at some point in the future.

                                      Callbacks functions - are functions that will be executed when a response is received from the server.
                                        -->


                                        <!-- CARROUSEL -->
                                         <!-- 
                                              // src/components/WiseTvCarousel.js
import React from 'react';
import { Carousel } from 'react-responsive-carousel';
import 'react-responsive-carousel/lib/styles/carousel.min.css';
import { Link } from 'react-router-dom';

// Import local images
import studioImage from '../assets/studio.jpg';
import filmSetImage from '../assets/filmset.jpg';
import cinemaImage from '../assets/cinema.jpg';

// Debug: Log the image imports to verify they are loading
console.log('Studio Image:', studioImage);
console.log('Film Set Image:', filmSetImage);
console.log('Cinema Image:', cinemaImage);

// Define carousel items with local images
const carouselItems = [
  {
    src: studioImage,
    alt: 'TV Studio',
    caption: 'Behind the Scenes: TV Studio',
  },
  {
    src: filmSetImage,
    alt: 'Film Set',
    caption: 'Action on the Film Set',
  },
  {
    src: cinemaImage,
    alt: 'Cinema',
    caption: 'Cinema Experience',
  },
];

const WiseTvCarousel = () => {
  return (
    <section className="relative h-screen">
      <Carousel
        autoPlay={true}
        infiniteLoop={true}
        showThumbs={false}
        showStatus={false}
        showArrows={true}
        interval={3000}
        emulateTouch={true}
        swipeable={true}
        dynamicHeight={false}
        className="h-full w-full"
      >
        {carouselItems.map((item, index) => (
          <div key={index} className="relative w-full h-screen">
            <img
              src={item.src}
              alt={item.alt}
              className="w-full h-full object-cover"
              style={{ display: 'block' }}
              onError={(e) => {
                console.log(Failed to load image: ${item.alt});
                e.target.src = 'https://via.placeholder.com/1200x600/CCCCCC/FFFFFF?text=Image+Not+Found';
              }}
            />
            <p className="legend bg-red-600 text-white text-sm font-semibold px-3 py-1 rounded">
              {item.caption}
            </p>
          </div>
        ))}
      </Carousel>

      {/* Overlay with Headline, Tagline, and CTA */}
      <div className="absolute inset-0 flex items-center justify-center bg-opacity-50">
        <div className="text-center text-white px-4">
          <h1 className="text-4xl md:text-6xl font-bold mb-4 drop-shadow-lg">
            Welcome to WiseTV
          </h1>
          <p className="text-lg md:text-2xl mb-6 drop-shadow-lg">
            Empowering the Next Generation with Inspiring Stories
          </p>
          <Link
            to="/watch"
            className="inline-block bg-red-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-red-500 transition-colors shadow-lg"
          >
            Watch Now
          </Link>
        </div>
      </div>
    </section>
  );
};

export default WiseTvCarousel;
                                         -->



                                        <!-- BACKEND -->
                                         <!-- new XMLHttpRequest(); - this creates a new XMLHttpRequest object, which is used to interact with servers -->
                                         <!-- It can be used to send and receive data asynchronously -->
                                         <!-- Commonly used for making API calls in web applications -->
                                          <!-- the lists of all the url paths that are supported to interact with the backend are called backend API's -->     <!-- Example of a backend API endpoint -->
                                           <!-- NB:using the url of a browser extension is the same as sending a 'GET' request to the backend of the said site -->
                                            <!--  a callback function is a function that is passed as an argument to another function and is executed after some kind of event occurs or a task is completed eg. setInterval() -->
                                              <!-- PROMISES -->
                                               <!-- Promises are a way to handle asynchronous operations in JavaScript -->
                                               <!-- They represent a value that may be available now, or in the future, or never -->
                                               <!-- promises lets us WAIT for some code to finish before we can continue with the rest of the code -->
                                                <!-- promise is a built-in class and when created needs to host a function which runs immediately, eg. new Promise((resolve) => {}) -->
                                                 <!-- resolve is a function that lets us control when to go to the next step in the promise chain -->
                                                  <!-- promises help keep our code flat and avoids nesting of callbacks -->
                                                   <!-- when we give a resolve function a value , it will be passed to the next .then(value) in the chain. this helps in sharing data between two steps in the promise chain -->
                                                    <!-- promise.all allows us to run multiple promises at the same time to resolve before proceeding -->
                                                    <!-- Example: -->
                                                    <!-- Promise.all([promise1, promise2]).then((results) => { ... }); -->

                                                    <!-- FETCH -->
                                                     <!-- fetch is a better way to make http requests in modern browsers -->
                                                      <!-- fetch makes an http request and returns a promise -->
                                                      <!-- fetch() is a built -in function that returns a promise from an HTTP request -->
                                                      <!-- Example: -->
                                                      <!-- fetch('https://api.example.com/data') -->
                                                      <!--   .then((response) => response.json()) -->
                                                      <!--   .then((data) => { ... }) -->
                                                      <!--   .catch((error) => { ... }); -->
                                                         <!-- fetch saves the response of its request in the parameter of the first .then()ie. then(response) -->
                                                          <!-- to access the data attached to the response, we use the .json() method ie. response.json(). this gives us the json data attached to the response -->
                                                           <!-- NB:response.json() is actually asynchronous and returns a promise -->
                                                            <!-- when we return a promise, we are basically waiting for the asynchronous operation to complete before proceeding which means we can use .then() to handle the result of the promise -->
                                                             <!-- once response.json() is finished, its gonna return that data which gets saved in the parameter of the next .then() ie. then(data) -->

                                                             <!-- ASYNC AND AWAIT -->
                                                              <!-- async- it makes a function return a promise -->
                                                               <!-- await- it makes a function wait for a promise to finish before moving to the next line -->
                                                                <!-- await lets us write asynchronous code that looks like normal code -->
                                                                <!-- Example: -->
                                                                <!-- async function fetchData() { -->
                                                                <!--   const response = await fetch('https://api.example.com/data'); -->
                                                                <!--   const data = await response.json(); -->
                                                                <!--   console.log(data); -->
                                                                <!-- } -->
                                                                <!-- with 'await' theres no need for .then() -->
                                                                 <!-- We can only use 'await' inside 'async' functions -->
                                                                  <!-- async-await is only relevant to promises and has nothing to do with callbacks -->
                                                                   <!-- the closest to await has to be async -->
                                                                    <!-- if a promise 'resolves' in a value, then the value is passed to the next .then() in the chain, however with await, it gets returned which acn be saved in a variable -->
                                                                     <!-- MY QUESTION -->
                                                                      <!-- when a function is a assigned async, does it mean when the function is called , the async insures that the function's promise is completed before moving to the next line? -->
                                                                       <!-- THE ANSWER -->
                                                                        <!-- JavaScript will pause execution inside that async function until the fetch promise is resolved, but it does NOT block the rest of the program.-->

                                                                    <!-- REQUEST -->
                                                                     <!-- there are 4 types of requests -->
                                                                      <!-- GET- get something from the backend
                                                                           POST- create something
                                                                           PUT- update something
                                                                           DELETE- delete something
                                                                        -->
                                                                    <!-- to send data in a request to the backend we use POST  -->
                                                                     <!-- "headers" gives the backend more information about the request and this is needed when we are sending data to the backend -->
                                                                     <!-- GET doesn't allow us get send data to the backend -->

                                                                     <!-- windows.location is a built in javascript object that lets us control the current URL of the browser window. windows.location.href is the current URL of the window. -->

                                                                     <!-- URL PARAMETERS -->
                                                                      <!-- url parameters let you save data in the URL, which can be useful for things like filtering or searching. -->


                <!-- FIREBASE -->
                 <!-- {InitializeApp} is a function provided by firebase that helps you initialize your firebase application with the project's configuration (API key, project ID, etc) -->
                  <!-- Without initializing Firebase, you can’t use services like Auth, Firestore, etc. -->
                   <!-- Once you call initializeApp(firebaseConfig), your Firebase services are ready to be used in your app. -->

                   <!-- getFireStore() -->
                    <!-- getFireStore() is a function from Firebase that initializes Firestore, which is Firebase's cloud-based NoSQL database. -->
                     <!-- It returns a REFERENCE TO YOUR FIRESTORE DATABASE so you can read, write, or listen to data. -->
                      <!-- In relation to const db = getFirestore(app), app tells getFirestore() which Firebase project to use (based on your firebaseConfig). -->

                  <!-- DOC() -->
                 <!-- doc() in firebase lets us create an instance of a document/ get a reference to the document in the collection.ie. a particular document(row) of a collection(table) in the database -->
                  <!-- NB: the reason sometimes in the onclick attribute, we call the function to execute straightforward like onclick={create} and other times, put it in a function like this onclick={() => {editFunction(id)}} is because of the arguments to be passed to the function eg.id, -->

                  <!-- NB: const auth = getAuth(app) -->
                   <!-- The auth instance represents the authentication system itself — not the current user, but the entire Firebase Auth service for your app.

                    It’s like the controller that:

                    Handles sign-in/sign-out

                    Stores the current user

                    Manages sessions

                    Gives access to useful methods like signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, and onAuthStateChanged -->
                    <!-- auth.currentUser holds the current status of the auth system.ie. whether this user is already signed in or not however, the problem here is that, When the app loads, Firebase needs a second to figure out if a user is already signed in (like after a page refresh). or this particular user is already signed in, just that the page refreshed and such could cause an error . this is where onAuthStateChanged comes in -->

                  <!-- NB:onAuthStateChanged is a Firebase function that listens for changes in the user's authentication state — in real time. -->
                   <!-- onAuthStateChanged(auth, (CurrentUser) => {
                    if (CurrentUser) {
                      console.log("User is signed in:", currentUser.email);
                    } else {
                      console.log("No user is signed in");
                    }
                  }); -->
                  <!-- auth: your Firebase Auth instance. -->
                   <!-- A callback function that runs every time the auth state changes. -->
                    <!-- What constitutes an auth state change? -->
                     <!-- When:

                      A user logs in

                      A user logs out

                      The app refreshes and Firebase automatically signs the user back in

                      The user’s session expires

                      → Firebase calls your callback with the latest user info (or null if signed out). -->
                      <!-- currentUser is:

                        An object (with details like email, uid, etc.) if the user is logged in and

                        null if no one is logged in -->
                        


                        <!--  Here's what happens during a page refresh:
                        Page reloads ➝ all JS is re-run from scratch.

                        Firebase needs to check local storage (or cookies/session) to see:

                        "Is there a user already signed in from a previous session?"

                        This check takes a little time, and during that time:

                        auth.currentUser is usually null ⚠️ (even if a user is signed in!)

                        So, if you immediately access auth.currentUser, you'll likely get null. -->
                        <!-- onAuthStateChanged waits behind the scenes for Firebase to finish that session check, then gives you the actual result: -->

                        <!-- NB: If the signup/logIn is successful, Firebase returns a UserCredential object. -->

                        

                        <!-- WITH RESPECT TO THE SIGN IN AND SIGN UP PROCESS, THE FOLLOWING IS IMPORTANT TO KNOW: -->
                         <!-- try { ... } catch (error) { ... }
                          This is JavaScript’s error handling.

                          Code inside the try block is attempted.

                          If anything fails (like invalid email, weak password, or network issues), it jumps to the catch block so your app doesn’t crash.

                          error.message gives a human-readable description of what went wrong. -->

                          <!-- BIG DISCOVERY -->
                           <!-- try {
                            const userCredentials = await createUserWithEmailAndPassword(
                              auth,
                              registeredEmail,
                              registeredPassword
                            );
                            console.log(userCredentials);
                          } catch (error) {
                            console.log(error.message);
                          } -->
                            <!-- IF this is successful, firebase returns 
                            {
                              user: {
                                uid: "abc123XYZ",
                                email: "example@email.com",
                                emailVerified: false,
                                displayName: null,
                                photoURL: null,
                                isAnonymous: false,
                                metadata: {
                                  creationTime: "Fri, 08 Aug 2025 12:00:00 GMT",
                                  lastSignInTime: "Fri, 08 Aug 2025 12:00:00 GMT"
                                },
                                providerData: [
                                  {
                                    providerId: "password",
                                    uid: "example@email.com",
                                    displayName: null,
                                    email: "example@email.com",
                                    phoneNumber: null,
                                    photoURL: null
                                  }
                                ]
                              },
                              providerId: null,
                              operationType: "signIn"
                            }
                             which would be now saved in the userCredentials variable.
                             console.log(userCredentials.user) would print out the user’s data.
                            
                            -->


                            <!-- NODE JS -->
                             <!-- When you require a modal, you request v8 to execute the code in that modal's context. -->
                              <!-- You can use module.exports to expose functions or variables from a module so they can be used in other files. -->
                               <!-- NB: the value of the module.exports object is equal to what gets exported from the module when the module is required in another file.ie. require(./add.js) === (module.exports = addFn) and as such can be saved in a variable ie. const add = require(./add.js) -->
                                <!-- By wrapping a module code in an iife with 5 parameters, node.js provides a few global looking variable that are specific to the module's context. -->
                                 <!--NB: Before a module is executed, Node.js wraps it in a function with 5 parameters: require, exports, module, __filename, and __dirname. They are available for use in every module -->
                                 <!-- In Node.js, require caches modules. That means if you import the same file multiple times, Node doesn’t create a new object each time — it gives you the same instance from memory.So in instances where you import a module, and you modify it, those changes will be reflected everywhere the module is imported. -->

                                 <!-- // math.js
                                  function add(a, b) {
                                    return a + b;
                                  }
                                  module.exports = add;

                                  // app.js
                                  const add = require("./math");
                                  console.log(add(2, 3)); // 5 -->
                                  <!-- So require("./math") is the function. -->

                                  <!--

                                 // math.js
                                  function add(a, b) {
                                    return a + b;
                                  }
                                  module.exports = { add };

                                  // app.js
                                  const math = require("./math");
                                  console.log(math.add(2, 3)); // 5-->
                                  <!-- So require("./math") is the object containing the add function. -->

                                  <!-- NB: Use the direct export (module.exports = fn) when your module exports just one thing.Use the object export (module.exports = { fn1, fn2 }) when your module has multiple functions or values. -->

                                  <!-- exports is just a reference to module.exports hence if you assign to exports, you are not changing module.exports however, node.js only returns module.exports when you require a module. -->


                                  <!-- ESM -->
                                   <!-- The file extensions in ESM is mjs and not js  -->
